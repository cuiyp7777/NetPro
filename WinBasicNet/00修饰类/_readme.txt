一、static
  修饰属性，方法，代码块

	1、静态属性：全类公有，称为类变量,初始化，类加载的过程是进行一次。也就是类变量只会被创建一次。
	2、静态方法：
	   使这个方法成为整个类所公有的方法，可以用   类名.方法名  直接访问  
	3、初始代码块
	   在定义属性的位置上，在任何方法之外，定义一个代码块  
	   动态初始代码块：在初始化属性之前调用初始化代码块  {……}
	   静态初始代码块：在类加载时运行    static{……}  只被运行一次，往往用作一个类的准备工作

二、final
 修饰变量，方法，类
	 1、修饰变量
	   被fianl修饰的变量就是常量（常量名大写），一旦赋值不能改变  
	 2、修饰方法                 
		不能被子类覆盖  
		从面向对象的角度理解，可以保持操作的稳定性
	 3、修饰类
		不能被继承  
		在树状单继承关系中，final类是树叶节点

三、abstract 抽象的

1、修饰类 ->  抽象类
  不能创建对象，可以声明引用，并通过引用调用类中的方法
  主要用于被子类继承的，可以用父类引用指向子类对象(简单工厂模式？)
 2、修饰方法
    只有声明，没有实现，用“；”代替“{ }”    
    需要子类继承实现（覆盖）
	如果一个类中有抽象方法，那么这个类必须是抽象类。
    抽象类中不一定有抽象方法

	父类是抽象类，其中有抽象方法，子类继承父类，必须把父类中的所有抽象方法都实现（覆盖）了，子类才有创建对象的能力，否则子类也必须是抽象类。

	抽象类的合理性：
     	没有抽象类的实例，只有抽象类子类的实例
     	抽象方法，定义和实现分离    
      
     	抽象（abstract）方法代表了某种标准，定义标准，定义功能，在子类中去实现功能（子类继承了父类并需要给出从父类继承的抽象方法的实现）。
     	方法一时间想不到怎么被实现，或有意要子类去实现而定义某种标准，这个方法可以被定义为抽象。(abstract) 

	四、三个修饰符都能修饰方法（不包含构造方法）
 	 1、构造方法在创建对象的时候使用，如果是static，那么只会在加载类的时候调用一次
  	   构造方法不能被继承（final），谈不到覆盖，更不会由子类实现（abstract）
 	 2、final和abstract，private和abstract，static和abstract，这些是不能放在一起的修饰符
  	   因为abstract修饰的方法是必须在其子类中实现（覆盖），才能以多态方式调用，以上修饰符在修饰方法时子类都覆盖不了这个方法。
  	   final是不可以覆盖，private是不能够继承到子类，所以也就不能覆盖。
  	   static是可以覆盖的，但是在调用时会调用编译时类型的方法（引用类型的方法），因为调用的是父类的方法，而父类的方法又是抽象的方法，不能调用。
  	   所以上的修饰符不能放在一起。 